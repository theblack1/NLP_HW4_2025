import sqlite3
import numpy as np
import multiprocessing as mp
import time
from typing import List
from queue import Empty
import os
import re
import pickle
import random
from tqdm import tqdm

from concurrent.futures import ThreadPoolExecutor, as_completed, TimeoutError
from typing import List, Any

import torch

DB_PATH = 'data/flight_database.db'

def compute_metrics(gt_path: str, model_path: str, gt_query_records: str = None, model_query_records: str = None):
    '''
    Main function to compute the three metrics used for evaluation: 
        * Exact match for SQL queries
        * Exact match for database records returned by queries
        * F1 score for database records returned by queries

    Inputs:
        * gt_path (str): The path to the ground-truth SQL queries corresponding to the text prompts
        * model_path (str): The path to SQL queries generated by the model, conditioned on the same text prompts
        * gt_query_records (str): If provided, it should be a path to a pickle file containing a list of records
                                  returned by the ground-truth SQL queries.
        * model_query_records (str): If provided, it should be a path to a pickle file containing a list of records
                                     returned by the model-generated SQL queries.
    '''
    gt_qs, gt_records, _ = load_queries_and_records(gt_path, gt_query_records)
    model_qs, model_records, model_error_msgs = load_queries_and_records(model_path, model_query_records)

    sql_em = compute_sql_exact_match(gt_qs, model_qs)
    record_em = compute_record_exact_match(gt_records, model_records)
    record_f1 = compute_record_F1(gt_records, model_records)

    return sql_em, record_em, record_f1, model_error_msgs

def load_queries_and_records(sql_path: str, record_path: str):
    '''
    Helper function for loading saved SQL queries and for computing the
    dataset records associated with said queries.

    Inputs:
        * sql_path (str): Path to a .sql file containing SQL queries
        * record_path (str): If provided, a path to a .pkl file containing dataset
                             records associated with each SQL query in sql_path.
    '''
    read_qs = read_queries(sql_path)

    if record_path is not None:
        with open(record_path, 'rb') as f:
            records, error_msgs = pickle.load(f)
    else:
        records, error_msgs = compute_records(read_qs)

    return read_qs, records, error_msgs

def save_queries_and_records(sql_queries: List[str], sql_path: str, record_path: str):
    '''
    Helper function to save model generated SQL queries and their associated records
    to the specified paths.

    Inputs: 
        * sql_queries (List[str]): The list of SQL queries to save
        * sql_path (str): Path to save SQL queries
        * record_path (str): Path to save database records associated with queries
    '''
    # First save the queries
    with open(sql_path, 'w') as f:
        for query in sql_queries:
            f.write(f'{query}\n')

    # Next compute and save records
    records, error_msgs = compute_records(sql_queries)    
    with open(record_path, 'wb') as f:
        pickle.dump((records, error_msgs), f)

def read_queries(sql_path: str):
    with open(sql_path, 'r') as f:
        qs = [q.strip() for q in f.readlines()]
    return qs

def _worker(idx: int, query: str, result_queue: mp.Queue):
    """Run compute_record in a separate process and report back the result."""
    try:
        # compute_record must be importable / defined at top level
        query_id, rec, error_msg = compute_record(idx, query)
        result_queue.put((idx, query_id, rec, error_msg, None))
    except Exception as e:
        # Return the exception message as error_msg
        result_queue.put((idx, None, [], f"Exception in compute_record: {e}", repr(e)))

def compute_records(processed_qs: List[str]):
    num_workers = 10               # Max concurrent processes
    per_query_timeout_secs = 120   # Per-query timeout

    n = len(processed_qs)
    recs: List[List] = [[] for _ in range(n)]
    error_msgs: List[str] = ["Unknown error" for _ in range(n)]

    if n == 0:
        return recs, error_msgs

    result_queue: mp.Queue = mp.Queue()

    # active: idx -> (proc, start_time)
    active = {}
    next_to_start = 0
    finished = set()

    pbar = tqdm(total=n, desc="Computing Records")

    try:
        while len(finished) < n:
            # 1) Start new workers while we have capacity
            while next_to_start < n and len(active) < num_workers:
                idx = next_to_start
                p = mp.Process(target=_worker, args=(idx, processed_qs[idx], result_queue))
                p.daemon = True  # Do not block interpreter exit
                p.start()
                active[idx] = (p, time.monotonic())
                next_to_start += 1

            # 2) Check timeouts and clean up timed-out processes
            now = time.monotonic()
            for idx in list(active.keys()):
                if idx in finished:
                    continue
                proc, start_time = active[idx]
                elapsed = now - start_time
                if elapsed > per_query_timeout_secs:
                    # Kill the stuck process
                    if proc.is_alive():
                        proc.terminate()
                    proc.join(timeout=1.0)
                    recs[idx] = []
                    error_msgs[idx] = "Query timed out"
                    finished.add(idx)
                    del active[idx]
                    pbar.update(1)

            # 3) Drain results without blocking
            try:
                while True:
                    idx, query_id, rec, error_msg, _exc_repr = result_queue.get_nowait()
                    # Skip if we already marked this index as finished by timeout
                    if idx in finished:
                        continue
                    recs[idx] = rec
                    error_msgs[idx] = error_msg
                    finished.add(idx)

                    # Clean up process if it is still around
                    proc, _start_time = active.pop(idx, (None, None))
                    if proc is not None and proc.is_alive():
                        proc.join(timeout=1.0)

                    pbar.update(1)
            except Empty:
                # No more results for now
                pass

            # 4) Small sleep to avoid busy loop
            if len(finished) < n:
                time.sleep(0.05)
    finally:
        pbar.close()

        # Best-effort cleanup of any remaining processes
        for idx, (proc, _start_time) in active.items():
            if proc.is_alive():
                proc.terminate()
            proc.join(timeout=1.0)

    return recs, error_msgs

def compute_record(query_id, query):
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()

    try:
        cursor.execute(query)
        rec = cursor.fetchall()
        error_msg = ""
    except Exception as e:
        rec = []
        error_msg = f"{type(e).__name__}: {e}"

    conn.close()
    return query_id, rec, error_msg

def compute_sql_exact_match(gt_qs: List[str], model_qs: List[str]):
    '''
    Helper function to compute exact match between ground-truth
    and model generated SQL queries.
    '''
    total = 0
    ems = 0
    pbar = tqdm(zip(gt_qs, model_qs), total=len(gt_qs), desc="Computing SQL EM")
    for gt_q, model_q in pbar:
        total += 1
        ems += 1 if gt_q == model_q else 0
    pbar.close()
    return ems / total

def compute_record_exact_match(gt_records: List[Any], model_records: List[Any]):
    '''
    Helper function to compute exact match between records
    generated by ground-truth and model SQL queries
    '''
    total = 0
    ems = 0
    pbar = tqdm(zip(gt_records, model_records), total=len(gt_records), desc="Computing Record EM")
    for gt_rec, model_rec in pbar:
        total += 1
        ems += 1 if set(gt_rec) == set(model_rec) else 0
    pbar.close()
    return ems / total

def compute_record_F1(gt_records: List[Any], model_records: List[Any]):
    '''
    Helper function to compute F1 between records
    generated by ground-truth and model SQL queries
    '''
    F1s = []
    pbar = tqdm(zip(gt_records, model_records), total=len(gt_records), desc="Computing Record F1")
    for gt_rec, model_rec in pbar:
        gt_set = set(gt_rec)
        model_set = set(model_rec)        

        precision_total = len(model_set)
        if precision_total == 0:
            precision = 1
        else:
            precision = len([rec for rec in model_set if rec in gt_set]) / precision_total
    
        recall_total = len(gt_set)    
        if recall_total == 0:
            recall = 1
        else:
            recall = len([rec for rec in gt_set if rec in model_set]) / recall_total

        F1 = 2 * precision * recall / (precision + recall + 1e-8)
        F1s.append(F1)
        
    pbar.close()

    return np.mean(F1s)

def set_random_seeds(seed_value=42):
    '''
    Set random seeds for better reproducibility
    '''
    random.seed(seed_value)
    np.random.seed(seed_value)
    
    torch.manual_seed(seed_value)
    torch.cuda.manual_seed(seed_value)
    torch.cuda.manual_seed_all(seed_value)
    torch.backends.cudnn.deterministic = True
    torch.backends.cudnn.benchmark = False
